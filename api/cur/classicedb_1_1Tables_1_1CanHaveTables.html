<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>icedb: icedb::Tables::CanHaveTables Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">icedb
   &#160;<span id="projectnumber">version 0.5.1</span>
   </div>
   <div id="projectbrief">Snow particle scattering database API</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceicedb.html">icedb</a></li><li class="navelem"><a class="el" href="namespaceicedb_1_1Tables.html">Tables</a></li><li class="navelem"><a class="el" href="classicedb_1_1Tables_1_1CanHaveTables.html">CanHaveTables</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="classicedb_1_1Tables_1_1CanHaveTables-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">icedb::Tables::CanHaveTables Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>The virtual base class used in all objects that can contain tables (groups and datasets).  
 <a href="classicedb_1_1Tables_1_1CanHaveTables.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Table_8hpp_source.html">Table.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for icedb::Tables::CanHaveTables:</div>
<div class="dyncontent">
<div class="center"><img src="classicedb_1_1Tables_1_1CanHaveTables__inherit__graph.png" border="0" usemap="#icedb_1_1Tables_1_1CanHaveTables_inherit__map" alt="Inheritance graph"/></div>
<map name="icedb_1_1Tables_1_1CanHaveTables_inherit__map" id="icedb_1_1Tables_1_1CanHaveTables_inherit__map">
<area shape="rect" id="node2" href="classicedb_1_1Groups_1_1Group.html" title="A group is similar to a folder / directory. It can have Attributes and Tables. " alt="" coords="263,80,410,107"/>
<area shape="rect" id="node6" href="classicedb_1_1Tables_1_1CanHaveTables__impl.html" title="icedb::Tables::CanHaveTables_impl" alt="" coords="5,80,239,107"/>
<area shape="rect" id="node3" href="classicedb_1_1Groups_1_1Group__impl.html" title="icedb::Groups::Group_impl" alt="" coords="60,155,237,181"/>
<area shape="rect" id="node5" href="classicedb_1_1Shapes_1_1Shape.html" title="A high&#45;level class to manipulate particle shapes. " alt="" coords="261,155,412,181"/>
<area shape="rect" id="node4" href="classicedb_1_1Shapes_1_1Shape__impl.html" title="icedb::Shapes::Shape_impl" alt="" coords="151,229,333,256"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:adb3ec74790d59a260e9f9b722e55f123"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicedb_1_1Tables_1_1CanHaveTables.html#adb3ec74790d59a260e9f9b722e55f123">~CanHaveTables</a> ()</td></tr>
<tr class="separator:adb3ec74790d59a260e9f9b722e55f123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5adb51a296d3ad91766eabbd559d89f3"><td class="memItemLeft" align="right" valign="top">std::set&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicedb_1_1Tables_1_1CanHaveTables.html#a5adb51a296d3ad91766eabbd559d89f3">getTableNames</a> () const</td></tr>
<tr class="memdesc:a5adb51a296d3ad91766eabbd559d89f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lists all table names that are children of this object.  <a href="#a5adb51a296d3ad91766eabbd559d89f3">More...</a><br /></td></tr>
<tr class="separator:a5adb51a296d3ad91766eabbd559d89f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7aade90339d578cb6694b0f509435c8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicedb_1_1Tables_1_1CanHaveTables.html#ae7aade90339d578cb6694b0f509435c8">doesTableExist</a> (const std::string &amp;tableName) const</td></tr>
<tr class="memdesc:ae7aade90339d578cb6694b0f509435c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does a table exist with the given name.  <a href="#ae7aade90339d578cb6694b0f509435c8">More...</a><br /></td></tr>
<tr class="separator:ae7aade90339d578cb6694b0f509435c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade0b5a88f5f8baf5e3dfe10d6a621178"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicedb_1_1Tables_1_1CanHaveTables.html#ade0b5a88f5f8baf5e3dfe10d6a621178">unlinkTable</a> (const std::string &amp;tableName)</td></tr>
<tr class="memdesc:ade0b5a88f5f8baf5e3dfe10d6a621178"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlink a table. In HDF5, this is not the same as erasing a table, which never actually happens.  <a href="#ade0b5a88f5f8baf5e3dfe10d6a621178">More...</a><br /></td></tr>
<tr class="separator:ade0b5a88f5f8baf5e3dfe10d6a621178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5b93977857bea7b20303637a31f3f06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classicedb_1_1Tables_1_1Table.html#aaff173ce29705eeb147ba8bdd6684e02">Table::Table_Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicedb_1_1Tables_1_1CanHaveTables.html#ae5b93977857bea7b20303637a31f3f06">openTable</a> (const std::string &amp;tableName)</td></tr>
<tr class="separator:ae5b93977857bea7b20303637a31f3f06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2239650a143079927f0d8d3955794b9f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicedb_1_1Tables_1_1CanHaveTables.html#a2239650a143079927f0d8d3955794b9f">getChunkStrategy</a> (const std::vector&lt; size_t &gt; &amp;dims)</td></tr>
<tr class="memdesc:a2239650a143079927f0d8d3955794b9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default chunking strategy for this table. Used for storage i/o speed, and for compression.  <a href="#a2239650a143079927f0d8d3955794b9f">More...</a><br /></td></tr>
<tr class="separator:a2239650a143079927f0d8d3955794b9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bb019d112b85a3aab7b6668e72eca6d"><td class="memTemplParams" colspan="2">template&lt;class DataType &gt; </td></tr>
<tr class="memitem:a3bb019d112b85a3aab7b6668e72eca6d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classicedb_1_1Tables_1_1Table.html#aaff173ce29705eeb147ba8bdd6684e02">Table::Table_Type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classicedb_1_1Tables_1_1CanHaveTables.html#a3bb019d112b85a3aab7b6668e72eca6d">createTable</a> (const std::string &amp;tableName, const std::vector&lt; size_t &gt; &amp;dims, const std::vector&lt; size_t &gt; *chunks=nullptr)</td></tr>
<tr class="memdesc:a3bb019d112b85a3aab7b6668e72eca6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a table.  <a href="#a3bb019d112b85a3aab7b6668e72eca6d">More...</a><br /></td></tr>
<tr class="separator:a3bb019d112b85a3aab7b6668e72eca6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a313c55597f9621ead29bf213d0ac7b35"><td class="memTemplParams" colspan="2">template&lt;class DataType &gt; </td></tr>
<tr class="memitem:a313c55597f9621ead29bf213d0ac7b35"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classicedb_1_1Tables_1_1Table.html#aaff173ce29705eeb147ba8bdd6684e02">Table::Table_Type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classicedb_1_1Tables_1_1CanHaveTables.html#a313c55597f9621ead29bf213d0ac7b35">createTable</a> (const std::string &amp;tableName, std::initializer_list&lt; size_t &gt; dims, const std::vector&lt; size_t &gt; *chunks=nullptr)</td></tr>
<tr class="memdesc:a313c55597f9621ead29bf213d0ac7b35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a table.  <a href="#a313c55597f9621ead29bf213d0ac7b35">More...</a><br /></td></tr>
<tr class="separator:a313c55597f9621ead29bf213d0ac7b35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac43fbe4ca548e41466ca8c46809d459a"><td class="memTemplParams" colspan="2">template&lt;class DataType &gt; </td></tr>
<tr class="memitem:ac43fbe4ca548e41466ca8c46809d459a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classicedb_1_1Tables_1_1Table.html#aaff173ce29705eeb147ba8bdd6684e02">Table::Table_Type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classicedb_1_1Tables_1_1CanHaveTables.html#ac43fbe4ca548e41466ca8c46809d459a">createTable</a> (const std::string &amp;tableName, std::initializer_list&lt; size_t &gt; dims, std::initializer_list&lt; DataType &gt; data, const std::vector&lt; size_t &gt; *chunks=nullptr)</td></tr>
<tr class="memdesc:ac43fbe4ca548e41466ca8c46809d459a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a table and writes initial data. Used with small tables.  <a href="#ac43fbe4ca548e41466ca8c46809d459a">More...</a><br /></td></tr>
<tr class="separator:ac43fbe4ca548e41466ca8c46809d459a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84584a72922f5a5627491c513fecaf93"><td class="memTemplParams" colspan="2">template&lt;class DataType &gt; </td></tr>
<tr class="memitem:a84584a72922f5a5627491c513fecaf93"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classicedb_1_1Tables_1_1Table.html#aaff173ce29705eeb147ba8bdd6684e02">Table::Table_Type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classicedb_1_1Tables_1_1CanHaveTables.html#a84584a72922f5a5627491c513fecaf93">createTable</a> (const std::string &amp;tableName, std::initializer_list&lt; size_t &gt; dims, const std::vector&lt; DataType &gt; &amp;data, const std::vector&lt; size_t &gt; *chunks=nullptr)</td></tr>
<tr class="memdesc:a84584a72922f5a5627491c513fecaf93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a table and sets the table's initial data.  <a href="#a84584a72922f5a5627491c513fecaf93">More...</a><br /></td></tr>
<tr class="separator:a84584a72922f5a5627491c513fecaf93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b70424cd2139b163efc351a6a7ecd26"><td class="memTemplParams" colspan="2">template&lt;class DataType &gt; </td></tr>
<tr class="memitem:a1b70424cd2139b163efc351a6a7ecd26"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classicedb_1_1Tables_1_1Table.html#aaff173ce29705eeb147ba8bdd6684e02">Table::Table_Type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classicedb_1_1Tables_1_1CanHaveTables.html#a1b70424cd2139b163efc351a6a7ecd26">createTable</a> (const std::string &amp;tableName, std::initializer_list&lt; size_t &gt; dims, const gsl::span&lt; DataType &gt; &amp;data, const std::vector&lt; size_t &gt; *chunks=nullptr)</td></tr>
<tr class="memdesc:a1b70424cd2139b163efc351a6a7ecd26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a table and sets the table's initial data.  <a href="#a1b70424cd2139b163efc351a6a7ecd26">More...</a><br /></td></tr>
<tr class="separator:a1b70424cd2139b163efc351a6a7ecd26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a166b58a7cb9536ca630fbe54f3636bc0"><td class="memTemplParams" colspan="2">template&lt;class DataType &gt; </td></tr>
<tr class="memitem:a166b58a7cb9536ca630fbe54f3636bc0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classicedb_1_1Tables_1_1Table.html#aaff173ce29705eeb147ba8bdd6684e02">Table::Table_Type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classicedb_1_1Tables_1_1CanHaveTables.html#a166b58a7cb9536ca630fbe54f3636bc0">createTable</a> (const std::string &amp;tableName, std::initializer_list&lt; size_t &gt; dims, const gsl::span&lt; const DataType &gt; &amp;data, const std::vector&lt; size_t &gt; *chunks=nullptr)</td></tr>
<tr class="memdesc:a166b58a7cb9536ca630fbe54f3636bc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a table and sets the table's initial data.  <a href="#a166b58a7cb9536ca630fbe54f3636bc0">More...</a><br /></td></tr>
<tr class="separator:a166b58a7cb9536ca630fbe54f3636bc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a8019ab9ba8a0497d273c31e8c18c898c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicedb_1_1Tables_1_1CanHaveTables.html#a8019ab9ba8a0497d273c31e8c18c898c">CanHaveTables</a> ()</td></tr>
<tr class="memdesc:a8019ab9ba8a0497d273c31e8c18c898c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trivial constructor used when <a class="el" href="classicedb_1_1Tables_1_1CanHaveTables.html" title="The virtual base class used in all objects that can contain tables (groups and datasets). ">CanHaveTables</a> is a virtual base class.  <a href="#a8019ab9ba8a0497d273c31e8c18c898c">More...</a><br /></td></tr>
<tr class="separator:a8019ab9ba8a0497d273c31e8c18c898c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2b688bf42c28385cb72b60657396829"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicedb_1_1Tables_1_1CanHaveTables.html#ac2b688bf42c28385cb72b60657396829">_setTablesParent</a> (std::shared_ptr&lt; H5::Group &gt; obj)=0</td></tr>
<tr class="memdesc:ac2b688bf42c28385cb72b60657396829"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classicedb_1_1Tables_1_1CanHaveTables.html" title="The virtual base class used in all objects that can contain tables (groups and datasets). ">CanHaveTables</a> needs post-constructor setup. This sets the base HDF5 object that gets manipulated.  <a href="#ac2b688bf42c28385cb72b60657396829">More...</a><br /></td></tr>
<tr class="separator:ac2b688bf42c28385cb72b60657396829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a172ec1290f9cbe7a00a78b4498a4c6af"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; H5::Group &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicedb_1_1Tables_1_1CanHaveTables.html#a172ec1290f9cbe7a00a78b4498a4c6af">_getTablesParent</a> () const =0</td></tr>
<tr class="memdesc:a172ec1290f9cbe7a00a78b4498a4c6af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the base HDF5 object that is manipulated.  <a href="#a172ec1290f9cbe7a00a78b4498a4c6af">More...</a><br /></td></tr>
<tr class="separator:a172ec1290f9cbe7a00a78b4498a4c6af"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a9b13c766d128573254037748ae3d734d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicedb_1_1Tables_1_1CanHaveTables.html#a9b13c766d128573254037748ae3d734d">valid</a> () const</td></tr>
<tr class="memdesc:a9b13c766d128573254037748ae3d734d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks that the class is well-formed, constructed and activated. <a class="el" href="classicedb_1_1Tables_1_1CanHaveTables.html" title="The virtual base class used in all objects that can contain tables (groups and datasets). ">CanHaveTables</a> <em>needs</em> post-constructor setup.  <a href="#a9b13c766d128573254037748ae3d734d">More...</a><br /></td></tr>
<tr class="separator:a9b13c766d128573254037748ae3d734d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aada0f621a32ae3a5542c579b8329fe5a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicedb_1_1Tables_1_1CanHaveTables.html#aada0f621a32ae3a5542c579b8329fe5a">_createTable</a> (const std::string &amp;tableName, const std::type_index &amp;type, const std::vector&lt; size_t &gt; &amp;dims, const std::vector&lt; size_t &gt; &amp;chunks)</td></tr>
<tr class="memdesc:aada0f621a32ae3a5542c579b8329fe5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function to create a table. Does not write data.  <a href="#aada0f621a32ae3a5542c579b8329fe5a">More...</a><br /></td></tr>
<tr class="separator:aada0f621a32ae3a5542c579b8329fe5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The virtual base class used in all objects that can contain tables (groups and datasets). </p>

<p class="definition">Definition at line <a class="el" href="Table_8hpp_source.html#l00126">126</a> of file <a class="el" href="Table_8hpp_source.html">Table.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a8019ab9ba8a0497d273c31e8c18c898c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8019ab9ba8a0497d273c31e8c18c898c">&#9670;&nbsp;</a></span>CanHaveTables()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">icedb::Tables::CanHaveTables::CanHaveTables </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Trivial constructor used when <a class="el" href="classicedb_1_1Tables_1_1CanHaveTables.html" title="The virtual base class used in all objects that can contain tables (groups and datasets). ">CanHaveTables</a> is a virtual base class. </p>

<p class="definition">Definition at line <a class="el" href="Tables_8cpp_source.html#l00245">245</a> of file <a class="el" href="Tables_8cpp_source.html">Tables.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;{}</div></div><!-- fragment -->
</div>
</div>
<a id="adb3ec74790d59a260e9f9b722e55f123"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb3ec74790d59a260e9f9b722e55f123">&#9670;&nbsp;</a></span>~CanHaveTables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">icedb::Tables::CanHaveTables::~CanHaveTables </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Tables_8cpp_source.html#l00246">246</a> of file <a class="el" href="Tables_8cpp_source.html">Tables.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;{}</div></div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aada0f621a32ae3a5542c579b8329fe5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aada0f621a32ae3a5542c579b8329fe5a">&#9670;&nbsp;</a></span>_createTable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void icedb::Tables::CanHaveTables::_createTable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::type_index &amp;&#160;</td>
          <td class="paramname"><em>type_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>chunks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal function to create a table. Does not write data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tableName</td><td>is the name of the table. </td></tr>
    <tr><td class="paramname">type</td><td>is the type of the table. </td></tr>
    <tr><td class="paramname">dims</td><td>are the dimensions of the table. </td></tr>
    <tr><td class="paramname">chunks</td><td>are the HDF5 chunking parameters, used when writing a table.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Must ensure NetCDF-4 compatability. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Tables_8cpp_source.html#l00250">250</a> of file <a class="el" href="Tables_8cpp_source.html">Tables.cpp</a>.</p>

<p class="reference">References <a class="el" href="export-hdf5_8cpp_source.html#l00017">icedb::fs::hdf5::useZLIB()</a>, and <a class="el" href="Tables_8cpp_source.html#l00013">icedb::Tables::Table::valid()</a>.</p>
<div class="fragment"><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;        {</div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;            Expects(<a class="code" href="classicedb_1_1Tables_1_1CanHaveTables.html#a9b13c766d128573254037748ae3d734d">valid</a>());</div><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;            std::vector&lt;hsize_t&gt; hdata;</div><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;d : dims) hdata.push_back(static_cast&lt;hsize_t&gt;(d));</div><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;            std::vector&lt;hsize_t&gt; cdata;</div><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;c : chunks) cdata.push_back(static_cast&lt;hsize_t&gt;(c));</div><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;</div><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;            <span class="comment">//fs::hdf5::addDatasetArray</span></div><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;            <span class="comment">/* Turn on creation order tracking. */</span></div><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;            <span class="comment">//assert(H5Pset_attr_creation_order(plistid, H5P_CRT_ORDER_TRACKED | H5P_CRT_ORDER_INDEXED) &gt;= 0);</span></div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;            std::shared_ptr&lt;H5::DSetCreatPropList&gt; plist = std::make_shared&lt;H5::DSetCreatPropList&gt;();</div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;            <span class="keywordtype">int</span> fillvalue = -1;</div><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;            plist-&gt;setFillValue(H5::PredType::NATIVE_INT, &amp;fillvalue);</div><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;            plist-&gt;setChunk(static_cast&lt;int&gt;(cdata.size()), cdata.data());</div><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;            <span class="keywordflow">if</span> (<a class="code" href="namespaceicedb_1_1fs_1_1hdf5.html#aa823e59a8819be3d124fc64700385fe7">fs::hdf5::useZLIB</a>()) {</div><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;                plist-&gt;setDeflate(<a class="code" href="namespaceicedb_1_1fs_1_1hdf5.html#aa823e59a8819be3d124fc64700385fe7">fs::hdf5::useZLIB</a>());</div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;            }</div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;<span class="preprocessor">#if ICEDB_H5_CREATEPROPLIST_SETATTRCRTORDER == 1</span></div><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;            plist-&gt;setAttrCrtOrder(H5P_CRT_ORDER_TRACKED | H5P_CRT_ORDER_INDEXED);</div><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;<span class="preprocessor">#else</span></div><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;            {</div><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;                hid_t <span class="keywordtype">id</span> = plist-&gt;getId();</div><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;                herr_t e = H5Pset_attr_creation_order(<span class="keywordtype">id</span>, H5P_CRT_ORDER_TRACKED | H5P_CRT_ORDER_INDEXED);</div><div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;                <span class="keywordflow">if</span> (e &lt; 0) <span class="keywordflow">throw</span>;</div><div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;            }</div><div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;</div><div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;            <span class="keywordflow">if</span> (type_id == <span class="keyword">typeid</span>(uint64_t))fs::hdf5::createDatasetRaw&lt;uint64_t, H5::Group&gt;(<a class="code" href="classicedb_1_1Tables_1_1CanHaveTables.html#a172ec1290f9cbe7a00a78b4498a4c6af">_getTablesParent</a>().get(), tableName.c_str(), dims, plist);</div><div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (type_id == <span class="keyword">typeid</span>(int64_t))fs::hdf5::createDatasetRaw&lt;int64_t, H5::Group&gt;(<a class="code" href="classicedb_1_1Tables_1_1CanHaveTables.html#a172ec1290f9cbe7a00a78b4498a4c6af">_getTablesParent</a>().get(), tableName.c_str(), dims, plist);</div><div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (type_id == <span class="keyword">typeid</span>(uint32_t))fs::hdf5::createDatasetRaw&lt;uint32_t, H5::Group&gt;(<a class="code" href="classicedb_1_1Tables_1_1CanHaveTables.html#a172ec1290f9cbe7a00a78b4498a4c6af">_getTablesParent</a>().get(), tableName.c_str(), dims, plist);</div><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (type_id == <span class="keyword">typeid</span>(int32_t))fs::hdf5::createDatasetRaw&lt;int32_t, H5::Group&gt;(<a class="code" href="classicedb_1_1Tables_1_1CanHaveTables.html#a172ec1290f9cbe7a00a78b4498a4c6af">_getTablesParent</a>().get(), tableName.c_str(), dims, plist);</div><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (type_id == <span class="keyword">typeid</span>(uint16_t))fs::hdf5::createDatasetRaw&lt;uint16_t, H5::Group&gt;(<a class="code" href="classicedb_1_1Tables_1_1CanHaveTables.html#a172ec1290f9cbe7a00a78b4498a4c6af">_getTablesParent</a>().get(), tableName.c_str(), dims, plist);</div><div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (type_id == <span class="keyword">typeid</span>(int16_t))fs::hdf5::createDatasetRaw&lt;int16_t, H5::Group&gt;(<a class="code" href="classicedb_1_1Tables_1_1CanHaveTables.html#a172ec1290f9cbe7a00a78b4498a4c6af">_getTablesParent</a>().get(), tableName.c_str(), dims, plist);</div><div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (type_id == <span class="keyword">typeid</span>(uint8_t))fs::hdf5::createDatasetRaw&lt;uint8_t, H5::Group&gt;(<a class="code" href="classicedb_1_1Tables_1_1CanHaveTables.html#a172ec1290f9cbe7a00a78b4498a4c6af">_getTablesParent</a>().get(), tableName.c_str(), dims, plist);</div><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (type_id == <span class="keyword">typeid</span>(int8_t))fs::hdf5::createDatasetRaw&lt;int8_t, H5::Group&gt;(<a class="code" href="classicedb_1_1Tables_1_1CanHaveTables.html#a172ec1290f9cbe7a00a78b4498a4c6af">_getTablesParent</a>().get(), tableName.c_str(), dims, plist);</div><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (type_id == <span class="keyword">typeid</span>(<span class="keywordtype">float</span>))fs::hdf5::createDatasetRaw&lt;float, H5::Group&gt;(<a class="code" href="classicedb_1_1Tables_1_1CanHaveTables.html#a172ec1290f9cbe7a00a78b4498a4c6af">_getTablesParent</a>().get(), tableName.c_str(), dims, plist);</div><div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (type_id == <span class="keyword">typeid</span>(<span class="keywordtype">double</span>))fs::hdf5::createDatasetRaw&lt;double, H5::Group&gt;(<a class="code" href="classicedb_1_1Tables_1_1CanHaveTables.html#a172ec1290f9cbe7a00a78b4498a4c6af">_getTablesParent</a>().get(), tableName.c_str(), dims, plist);</div><div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (type_id == <span class="keyword">typeid</span>(<span class="keywordtype">char</span>))fs::hdf5::createDatasetRaw&lt;char, H5::Group&gt;(<a class="code" href="classicedb_1_1Tables_1_1CanHaveTables.html#a172ec1290f9cbe7a00a78b4498a4c6af">_getTablesParent</a>().get(), tableName.c_str(), dims, plist);</div><div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (type_id == <span class="keyword">typeid</span>(std::string))fs::hdf5::createDatasetRaw&lt;std::string, H5::Group&gt;(<a class="code" href="classicedb_1_1Tables_1_1CanHaveTables.html#a172ec1290f9cbe7a00a78b4498a4c6af">_getTablesParent</a>().get(), tableName.c_str(), dims, plist);</div><div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;            <span class="keywordflow">else</span> <span class="keywordflow">throw</span>(std::invalid_argument(<span class="stringliteral">&quot;Unhandled data type&quot;</span>));</div><div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;        }</div><div class="ttc" id="classicedb_1_1Tables_1_1CanHaveTables_html_a172ec1290f9cbe7a00a78b4498a4c6af"><div class="ttname"><a href="classicedb_1_1Tables_1_1CanHaveTables.html#a172ec1290f9cbe7a00a78b4498a4c6af">icedb::Tables::CanHaveTables::_getTablesParent</a></div><div class="ttdeci">virtual std::shared_ptr&lt; H5::Group &gt; _getTablesParent() const =0</div><div class="ttdoc">Gets the base HDF5 object that is manipulated. </div></div>
<div class="ttc" id="namespaceicedb_1_1fs_1_1hdf5_html_aa823e59a8819be3d124fc64700385fe7"><div class="ttname"><a href="namespaceicedb_1_1fs_1_1hdf5.html#aa823e59a8819be3d124fc64700385fe7">icedb::fs::hdf5::useZLIB</a></div><div class="ttdeci">int useZLIB()</div><div class="ttdef"><b>Definition:</b> <a href="export-hdf5_8cpp_source.html#l00017">export-hdf5.cpp:17</a></div></div>
<div class="ttc" id="classicedb_1_1Tables_1_1CanHaveTables_html_a9b13c766d128573254037748ae3d734d"><div class="ttname"><a href="classicedb_1_1Tables_1_1CanHaveTables.html#a9b13c766d128573254037748ae3d734d">icedb::Tables::CanHaveTables::valid</a></div><div class="ttdeci">bool valid() const</div><div class="ttdoc">Checks that the class is well-formed, constructed and activated. CanHaveTables needs post-constructor...</div><div class="ttdef"><b>Definition:</b> <a href="Tables_8cpp_source.html#l00247">Tables.cpp:247</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classicedb_1_1Tables_1_1CanHaveTables_aada0f621a32ae3a5542c579b8329fe5a_cgraph.png" border="0" usemap="#classicedb_1_1Tables_1_1CanHaveTables_aada0f621a32ae3a5542c579b8329fe5a_cgraph" alt=""/></div>
<map name="classicedb_1_1Tables_1_1CanHaveTables_aada0f621a32ae3a5542c579b8329fe5a_cgraph" id="classicedb_1_1Tables_1_1CanHaveTables_aada0f621a32ae3a5542c579b8329fe5a_cgraph">
<area shape="rect" id="node2" href="namespaceicedb_1_1fs_1_1hdf5.html#aa823e59a8819be3d124fc64700385fe7" title="icedb::fs::hdf5::useZLIB" alt="" coords="256,5,419,32"/>
<area shape="rect" id="node3" href="classicedb_1_1Tables_1_1Table.html#a87e0e23502ba591a6951ec1defaebdb1" title="Checks that Table is well&#45;formed during runtime. Only used internally. " alt="" coords="267,57,407,98"/>
<area shape="rect" id="node4" href="classicedb_1_1Tables_1_1Table.html#a9f9417a43751a0e5c7639ebfae870009" title="Gets the fundamental HDF5 DataSet associated with the table. Only used internally. " alt="" coords="467,57,607,98"/>
</map>
</div>

</div>
</div>
<a id="a172ec1290f9cbe7a00a78b4498a4c6af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a172ec1290f9cbe7a00a78b4498a4c6af">&#9670;&nbsp;</a></span>_getTablesParent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt;H5::Group&gt; icedb::Tables::CanHaveTables::_getTablesParent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the base HDF5 object that is manipulated. </p>

<p>Implemented in <a class="el" href="classicedb_1_1Tables_1_1CanHaveTables__impl.html#af639736754b21406c8455460173bafdf">icedb::Tables::CanHaveTables_impl</a>.</p>

</div>
</div>
<a id="ac2b688bf42c28385cb72b60657396829"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2b688bf42c28385cb72b60657396829">&#9670;&nbsp;</a></span>_setTablesParent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void icedb::Tables::CanHaveTables::_setTablesParent </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; H5::Group &gt;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classicedb_1_1Tables_1_1CanHaveTables.html" title="The virtual base class used in all objects that can contain tables (groups and datasets). ">CanHaveTables</a> needs post-constructor setup. This sets the base HDF5 object that gets manipulated. </p>

<p>Implemented in <a class="el" href="classicedb_1_1Tables_1_1CanHaveTables__impl.html#aa5b1a6035082f4a97942cdf9485e4689">icedb::Tables::CanHaveTables_impl</a>.</p>

</div>
</div>
<a id="a3bb019d112b85a3aab7b6668e72eca6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bb019d112b85a3aab7b6668e72eca6d">&#9670;&nbsp;</a></span>createTable() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classicedb_1_1Tables_1_1Table.html#aaff173ce29705eeb147ba8bdd6684e02">Table::Table_Type</a> icedb::Tables::CanHaveTables::createTable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; *&#160;</td>
          <td class="paramname"><em>chunks</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">DataType</td><td>is the type of the data </td></tr>
    <tr><td class="paramname">tableName</td><td>is the name of the table </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">if</td><td>a table with this name already exists </td></tr>
    <tr><td class="paramname">if</td><td>the base object is read only </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dims</td><td>are the dimensions of the table </td></tr>
    <tr><td class="paramname">chunks</td><td>is the size of each N-dimensional chunk, used for storage and compression. HDF5 writes each table as a group of chunked objects. When reading or writing, entire chunks are always read or written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new table. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Table_8hpp_source.html#l00172">172</a> of file <a class="el" href="Table_8hpp_source.html">Table.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;                                                                                                                                              {</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;                Expects(!<a class="code" href="classicedb_1_1Tables_1_1CanHaveTables.html#ae7aade90339d578cb6694b0f509435c8">doesTableExist</a>(tableName));</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;                std::vector&lt;size_t&gt; chunksGuess;</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;                <span class="keywordflow">if</span> (!chunks) {</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;                    chunksGuess = <a class="code" href="classicedb_1_1Tables_1_1CanHaveTables.html#a2239650a143079927f0d8d3955794b9f">getChunkStrategy</a>(dims);</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;                    chunks = &amp;chunksGuess;</div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;                }</div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;                <a class="code" href="classicedb_1_1Tables_1_1CanHaveTables.html#aada0f621a32ae3a5542c579b8329fe5a">_createTable</a>(tableName, Data_Types::getType&lt;DataType&gt;(), dims, *chunks);</div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;                <span class="keywordflow">return</span> <a class="code" href="classicedb_1_1Tables_1_1CanHaveTables.html#ae5b93977857bea7b20303637a31f3f06">openTable</a>(tableName);</div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;            }</div><div class="ttc" id="classicedb_1_1Tables_1_1CanHaveTables_html_ae7aade90339d578cb6694b0f509435c8"><div class="ttname"><a href="classicedb_1_1Tables_1_1CanHaveTables.html#ae7aade90339d578cb6694b0f509435c8">icedb::Tables::CanHaveTables::doesTableExist</a></div><div class="ttdeci">bool doesTableExist(const std::string &amp;tableName) const</div><div class="ttdoc">Does a table exist with the given name. </div><div class="ttdef"><b>Definition:</b> <a href="Tables_8cpp_source.html#l00309">Tables.cpp:309</a></div></div>
<div class="ttc" id="classicedb_1_1Tables_1_1CanHaveTables_html_ae5b93977857bea7b20303637a31f3f06"><div class="ttname"><a href="classicedb_1_1Tables_1_1CanHaveTables.html#ae5b93977857bea7b20303637a31f3f06">icedb::Tables::CanHaveTables::openTable</a></div><div class="ttdeci">Table::Table_Type openTable(const std::string &amp;tableName)</div><div class="ttdef"><b>Definition:</b> <a href="Tables_8cpp_source.html#l00321">Tables.cpp:321</a></div></div>
<div class="ttc" id="classicedb_1_1Tables_1_1CanHaveTables_html_a2239650a143079927f0d8d3955794b9f"><div class="ttname"><a href="classicedb_1_1Tables_1_1CanHaveTables.html#a2239650a143079927f0d8d3955794b9f">icedb::Tables::CanHaveTables::getChunkStrategy</a></div><div class="ttdeci">std::vector&lt; size_t &gt; getChunkStrategy(const std::vector&lt; size_t &gt; &amp;dims)</div><div class="ttdoc">The default chunking strategy for this table. Used for storage i/o speed, and for compression...</div><div class="ttdef"><b>Definition:</b> <a href="Table_8hpp_source.html#l00158">Table.hpp:158</a></div></div>
<div class="ttc" id="classicedb_1_1Tables_1_1CanHaveTables_html_aada0f621a32ae3a5542c579b8329fe5a"><div class="ttname"><a href="classicedb_1_1Tables_1_1CanHaveTables.html#aada0f621a32ae3a5542c579b8329fe5a">icedb::Tables::CanHaveTables::_createTable</a></div><div class="ttdeci">void _createTable(const std::string &amp;tableName, const std::type_index &amp;type, const std::vector&lt; size_t &gt; &amp;dims, const std::vector&lt; size_t &gt; &amp;chunks)</div><div class="ttdoc">Internal function to create a table. Does not write data. </div><div class="ttdef"><b>Definition:</b> <a href="Tables_8cpp_source.html#l00250">Tables.cpp:250</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a313c55597f9621ead29bf213d0ac7b35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a313c55597f9621ead29bf213d0ac7b35">&#9670;&nbsp;</a></span>createTable() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classicedb_1_1Tables_1_1Table.html#aaff173ce29705eeb147ba8bdd6684e02">Table::Table_Type</a> icedb::Tables::CanHaveTables::createTable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; size_t &gt;&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; *&#160;</td>
          <td class="paramname"><em>chunks</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">DataType</td><td>is the type of the data </td></tr>
    <tr><td class="paramname">tableName</td><td>is the name of the table </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">if</td><td>a table with this name already exists </td></tr>
    <tr><td class="paramname">if</td><td>the base object is read only </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dims</td><td>are the dimensions of the table </td></tr>
    <tr><td class="paramname">chunks</td><td>is the size of each N-dimensional chunk, used for storage and compression. HDF5 writes each table as a group of chunked objects. When reading or writing, entire chunks are always read or written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new table. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Table_8hpp_source.html#l00193">193</a> of file <a class="el" href="Table_8hpp_source.html">Table.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;            {</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;                std::vector&lt;size_t&gt; vdims{ dims };</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;                <span class="keyword">auto</span> tbl = createTable&lt;DataType&gt;(tableName, vdims, chunks);</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;                <span class="keywordflow">return</span> tbl;</div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;            }</div></div><!-- fragment -->
</div>
</div>
<a id="ac43fbe4ca548e41466ca8c46809d459a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac43fbe4ca548e41466ca8c46809d459a">&#9670;&nbsp;</a></span>createTable() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classicedb_1_1Tables_1_1Table.html#aaff173ce29705eeb147ba8bdd6684e02">Table::Table_Type</a> icedb::Tables::CanHaveTables::createTable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; size_t &gt;&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; DataType &gt;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; *&#160;</td>
          <td class="paramname"><em>chunks</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a table and writes initial data. Used with small tables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">DataType</td><td>is the type of the data </td></tr>
    <tr><td class="paramname">tableName</td><td>is the name of the table </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">if</td><td>a table with this name already exists </td></tr>
    <tr><td class="paramname">if</td><td>the base object is read only </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dims</td><td>are the dimensions of the table </td></tr>
    <tr><td class="paramname">data</td><td>are the initial data of the table </td></tr>
    <tr><td class="paramname">chunks</td><td>is the size of each N-dimensional chunk, used for storage and compression. HDF5 writes each table as a group of chunked objects. When reading or writing, entire chunks are always read or written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new table. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Table_8hpp_source.html#l00214">214</a> of file <a class="el" href="Table_8hpp_source.html">Table.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;            {</div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;                <span class="keyword">auto</span> tbl = createTable&lt;DataType&gt;(tableName, dims, chunks);</div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;                <span class="comment">//std::vector&lt;DataType&gt; vdata{ data };</span></div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;                tbl-&gt;template writeAll&lt;DataType&gt;(gsl::span&lt;const DataType&gt;(data.begin(), data.end()));</div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;                <span class="keywordflow">return</span> tbl;</div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;            }</div></div><!-- fragment -->
</div>
</div>
<a id="a84584a72922f5a5627491c513fecaf93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84584a72922f5a5627491c513fecaf93">&#9670;&nbsp;</a></span>createTable() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classicedb_1_1Tables_1_1Table.html#aaff173ce29705eeb147ba8bdd6684e02">Table::Table_Type</a> icedb::Tables::CanHaveTables::createTable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; size_t &gt;&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; DataType &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; *&#160;</td>
          <td class="paramname"><em>chunks</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a table and sets the table's initial data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">DataType</td><td>is the type of the data </td></tr>
    <tr><td class="paramname">tableName</td><td>is the name of the table </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">if</td><td>a table with this name already exists </td></tr>
    <tr><td class="paramname">if</td><td>the base object is read only </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dims</td><td>are the dimensions of the table </td></tr>
    <tr><td class="paramname">data</td><td>are the data of the table </td></tr>
    <tr><td class="paramname">chunks</td><td>is the size of each N-dimensional chunk, used for storage and compression. HDF5 writes each table as a group of chunked objects. When reading or writing, entire chunks are always read or written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new table. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Table_8hpp_source.html#l00237">237</a> of file <a class="el" href="Table_8hpp_source.html">Table.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;            {</div><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;                <span class="keyword">auto</span> tbl = createTable&lt;DataType&gt;(tableName, dims, chunks);</div><div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;                tbl-&gt;template writeAll&lt;DataType&gt;(data);</div><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;                <span class="keywordflow">return</span> tbl;</div><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;            }</div></div><!-- fragment -->
</div>
</div>
<a id="a1b70424cd2139b163efc351a6a7ecd26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b70424cd2139b163efc351a6a7ecd26">&#9670;&nbsp;</a></span>createTable() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classicedb_1_1Tables_1_1Table.html#aaff173ce29705eeb147ba8bdd6684e02">Table::Table_Type</a> icedb::Tables::CanHaveTables::createTable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; size_t &gt;&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gsl::span&lt; DataType &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; *&#160;</td>
          <td class="paramname"><em>chunks</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a table and sets the table's initial data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">DataType</td><td>is the type of the data </td></tr>
    <tr><td class="paramname">tableName</td><td>is the name of the table </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">if</td><td>a table with this name already exists </td></tr>
    <tr><td class="paramname">if</td><td>the base object is read only </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dims</td><td>are the dimensions of the table </td></tr>
    <tr><td class="paramname">data</td><td>are the data of the table </td></tr>
    <tr><td class="paramname">chunks</td><td>is the size of each N-dimensional chunk, used for storage and compression. HDF5 writes each table as a group of chunked objects. When reading or writing, entire chunks are always read or written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new table. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Table_8hpp_source.html#l00259">259</a> of file <a class="el" href="Table_8hpp_source.html">Table.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;            {</div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;                <span class="keyword">auto</span> tbl = createTable&lt;DataType&gt;(tableName, dims, chunks);</div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;                tbl-&gt;template writeAll&lt;DataType&gt;(data);</div><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;                <span class="keywordflow">return</span> tbl;</div><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;            }</div></div><!-- fragment -->
</div>
</div>
<a id="a166b58a7cb9536ca630fbe54f3636bc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a166b58a7cb9536ca630fbe54f3636bc0">&#9670;&nbsp;</a></span>createTable() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classicedb_1_1Tables_1_1Table.html#aaff173ce29705eeb147ba8bdd6684e02">Table::Table_Type</a> icedb::Tables::CanHaveTables::createTable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; size_t &gt;&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gsl::span&lt; const DataType &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; *&#160;</td>
          <td class="paramname"><em>chunks</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a table and sets the table's initial data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">DataType</td><td>is the type of the data </td></tr>
    <tr><td class="paramname">tableName</td><td>is the name of the table </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">if</td><td>a table with this name already exists </td></tr>
    <tr><td class="paramname">if</td><td>the base object is read only </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dims</td><td>are the dimensions of the table </td></tr>
    <tr><td class="paramname">data</td><td>are the data of the table </td></tr>
    <tr><td class="paramname">chunks</td><td>is the size of each N-dimensional chunk, used for storage and compression. HDF5 writes each table as a group of chunked objects. When reading or writing, entire chunks are always read or written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new table. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Table_8hpp_source.html#l00281">281</a> of file <a class="el" href="Table_8hpp_source.html">Table.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;            {</div><div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;                <span class="keyword">auto</span> tbl = createTable&lt;DataType&gt;(tableName, dims, chunks);</div><div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;                tbl-&gt;template writeAll&lt;DataType&gt;(data);</div><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;                <span class="keywordflow">return</span> tbl;</div><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;            }</div></div><!-- fragment -->
</div>
</div>
<a id="ae7aade90339d578cb6694b0f509435c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7aade90339d578cb6694b0f509435c8">&#9670;&nbsp;</a></span>doesTableExist()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool icedb::Tables::CanHaveTables::doesTableExist </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tableName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Does a table exist with the given name. </p>

<p class="definition">Definition at line <a class="el" href="Tables_8cpp_source.html#l00309">309</a> of file <a class="el" href="Tables_8cpp_source.html">Tables.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;                                                                           {</div><div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;            <span class="keyword">const</span> <span class="keyword">auto</span> tnames = <a class="code" href="classicedb_1_1Tables_1_1CanHaveTables.html#a5adb51a296d3ad91766eabbd559d89f3">getTableNames</a>();</div><div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;            <span class="keywordflow">if</span> (tnames.count(tableName)) <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;        }</div><div class="ttc" id="classicedb_1_1Tables_1_1CanHaveTables_html_a5adb51a296d3ad91766eabbd559d89f3"><div class="ttname"><a href="classicedb_1_1Tables_1_1CanHaveTables.html#a5adb51a296d3ad91766eabbd559d89f3">icedb::Tables::CanHaveTables::getTableNames</a></div><div class="ttdeci">std::set&lt; std::string &gt; getTableNames() const</div><div class="ttdoc">Lists all table names that are children of this object. </div><div class="ttdef"><b>Definition:</b> <a href="Tables_8cpp_source.html#l00297">Tables.cpp:297</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a2239650a143079927f0d8d3955794b9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2239650a143079927f0d8d3955794b9f">&#9670;&nbsp;</a></span>getChunkStrategy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;size_t&gt; icedb::Tables::CanHaveTables::getChunkStrategy </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The default chunking strategy for this table. Used for storage i/o speed, and for compression. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000010">Todo:</a></b></dt><dd>Use a more intelligent strategy </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the ideal size of each chunk of the dataset. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Table_8hpp_source.html#l00158">158</a> of file <a class="el" href="Table_8hpp_source.html">Table.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;                                                                                     {</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;                <span class="keywordflow">return</span> dims;</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;            }</div></div><!-- fragment -->
</div>
</div>
<a id="a5adb51a296d3ad91766eabbd559d89f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5adb51a296d3ad91766eabbd559d89f3">&#9670;&nbsp;</a></span>getTableNames()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt; std::string &gt; icedb::Tables::CanHaveTables::getTableNames </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lists all table names that are children of this object. </p>

<p class="definition">Definition at line <a class="el" href="Tables_8cpp_source.html#l00297">297</a> of file <a class="el" href="Tables_8cpp_source.html">Tables.cpp</a>.</p>

<p class="reference">References <a class="el" href="export-hdf5_8cpp_source.html#l00173">icedb::fs::hdf5::getGroupMembersTypes()</a>, and <a class="el" href="Tables_8cpp_source.html#l00013">icedb::Tables::Table::valid()</a>.</p>
<div class="fragment"><div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;                                                             {</div><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;            Expects(<a class="code" href="classicedb_1_1Tables_1_1CanHaveTables.html#a9b13c766d128573254037748ae3d734d">valid</a>());</div><div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;            <span class="keyword">auto</span> base = <a class="code" href="classicedb_1_1Tables_1_1CanHaveTables.html#a172ec1290f9cbe7a00a78b4498a4c6af">_getTablesParent</a>();</div><div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;            <span class="keyword">auto</span> objs = <a class="code" href="namespaceicedb_1_1fs_1_1hdf5.html#a17f149096e08391678f7369fbb97defe">fs::hdf5::getGroupMembersTypes</a>(*(base.get()));</div><div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;            std::set&lt;std::string&gt; res;</div><div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;o : objs)</div><div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;            {</div><div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;                <span class="keywordflow">if</span> (o.second == H5G_obj_t::H5G_DATASET) res.insert(o.first);</div><div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;            }</div><div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;            <span class="keywordflow">return</span> res;</div><div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;        }</div><div class="ttc" id="classicedb_1_1Tables_1_1CanHaveTables_html_a172ec1290f9cbe7a00a78b4498a4c6af"><div class="ttname"><a href="classicedb_1_1Tables_1_1CanHaveTables.html#a172ec1290f9cbe7a00a78b4498a4c6af">icedb::Tables::CanHaveTables::_getTablesParent</a></div><div class="ttdeci">virtual std::shared_ptr&lt; H5::Group &gt; _getTablesParent() const =0</div><div class="ttdoc">Gets the base HDF5 object that is manipulated. </div></div>
<div class="ttc" id="classicedb_1_1Tables_1_1CanHaveTables_html_a9b13c766d128573254037748ae3d734d"><div class="ttname"><a href="classicedb_1_1Tables_1_1CanHaveTables.html#a9b13c766d128573254037748ae3d734d">icedb::Tables::CanHaveTables::valid</a></div><div class="ttdeci">bool valid() const</div><div class="ttdoc">Checks that the class is well-formed, constructed and activated. CanHaveTables needs post-constructor...</div><div class="ttdef"><b>Definition:</b> <a href="Tables_8cpp_source.html#l00247">Tables.cpp:247</a></div></div>
<div class="ttc" id="namespaceicedb_1_1fs_1_1hdf5_html_a17f149096e08391678f7369fbb97defe"><div class="ttname"><a href="namespaceicedb_1_1fs_1_1hdf5.html#a17f149096e08391678f7369fbb97defe">icedb::fs::hdf5::getGroupMembersTypes</a></div><div class="ttdeci">std::map&lt; std::string, H5G_obj_t &gt; getGroupMembersTypes(const ICEDB_H5_GETNUMOBJS_OWNER &amp;base)</div><div class="ttdef"><b>Definition:</b> <a href="export-hdf5_8cpp_source.html#l00173">export-hdf5.cpp:173</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classicedb_1_1Tables_1_1CanHaveTables_a5adb51a296d3ad91766eabbd559d89f3_cgraph.png" border="0" usemap="#classicedb_1_1Tables_1_1CanHaveTables_a5adb51a296d3ad91766eabbd559d89f3_cgraph" alt=""/></div>
<map name="classicedb_1_1Tables_1_1CanHaveTables_a5adb51a296d3ad91766eabbd559d89f3_cgraph" id="classicedb_1_1Tables_1_1CanHaveTables_a5adb51a296d3ad91766eabbd559d89f3_cgraph">
<area shape="rect" id="node2" href="namespaceicedb_1_1fs_1_1hdf5.html#a17f149096e08391678f7369fbb97defe" title="icedb::fs::hdf5::getGroup\lMembersTypes" alt="" coords="256,5,423,47"/>
<area shape="rect" id="node3" href="classicedb_1_1Tables_1_1Table.html#a87e0e23502ba591a6951ec1defaebdb1" title="Checks that Table is well&#45;formed during runtime. Only used internally. " alt="" coords="269,71,409,112"/>
<area shape="rect" id="node4" href="classicedb_1_1Tables_1_1Table.html#a9f9417a43751a0e5c7639ebfae870009" title="Gets the fundamental HDF5 DataSet associated with the table. Only used internally. " alt="" coords="471,71,611,112"/>
</map>
</div>

</div>
</div>
<a id="ae5b93977857bea7b20303637a31f3f06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5b93977857bea7b20303637a31f3f06">&#9670;&nbsp;</a></span>openTable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classicedb_1_1Tables_1_1Table.html#aaff173ce29705eeb147ba8bdd6684e02">Table::Table_Type</a> icedb::Tables::CanHaveTables::openTable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tableName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Open the table with the matching name. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">if</td><td>a table with this name does not exist. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Tables_8cpp_source.html#l00321">321</a> of file <a class="el" href="Tables_8cpp_source.html">Tables.cpp</a>.</p>

<p class="reference">References <a class="el" href="Tables_8cpp_source.html#l00013">icedb::Tables::Table::valid()</a>.</p>
<div class="fragment"><div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;                                                                           {</div><div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;            Expects(<a class="code" href="classicedb_1_1Tables_1_1CanHaveTables.html#a9b13c766d128573254037748ae3d734d">valid</a>());</div><div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;            <span class="keyword">const</span> <span class="keyword">auto</span> base = <a class="code" href="classicedb_1_1Tables_1_1CanHaveTables.html#a172ec1290f9cbe7a00a78b4498a4c6af">_getTablesParent</a>();</div><div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;            <span class="keyword">const</span> <span class="keyword">auto</span> tbl = std::make_shared&lt;H5::DataSet&gt;(base-&gt;openDataSet(tableName));</div><div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;            <a class="code" href="classicedb_1_1Tables_1_1Table.html#aaff173ce29705eeb147ba8bdd6684e02">Table::Table_Type</a> res = std::make_unique&lt;Table_impl&gt;(tbl,tableName);</div><div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;            <span class="keywordflow">return</span> res;</div><div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;        }</div><div class="ttc" id="classicedb_1_1Tables_1_1Table_html_aaff173ce29705eeb147ba8bdd6684e02"><div class="ttname"><a href="classicedb_1_1Tables_1_1Table.html#aaff173ce29705eeb147ba8bdd6684e02">icedb::Tables::Table::Table_Type</a></div><div class="ttdeci">std::unique_ptr&lt; Table &gt; Table_Type</div><div class="ttdoc">The preferred method of access of a Table is through std::unique_ptr. </div><div class="ttdef"><b>Definition:</b> <a href="Table_8hpp_source.html#l00035">Table.hpp:35</a></div></div>
<div class="ttc" id="classicedb_1_1Tables_1_1CanHaveTables_html_a172ec1290f9cbe7a00a78b4498a4c6af"><div class="ttname"><a href="classicedb_1_1Tables_1_1CanHaveTables.html#a172ec1290f9cbe7a00a78b4498a4c6af">icedb::Tables::CanHaveTables::_getTablesParent</a></div><div class="ttdeci">virtual std::shared_ptr&lt; H5::Group &gt; _getTablesParent() const =0</div><div class="ttdoc">Gets the base HDF5 object that is manipulated. </div></div>
<div class="ttc" id="classicedb_1_1Tables_1_1CanHaveTables_html_a9b13c766d128573254037748ae3d734d"><div class="ttname"><a href="classicedb_1_1Tables_1_1CanHaveTables.html#a9b13c766d128573254037748ae3d734d">icedb::Tables::CanHaveTables::valid</a></div><div class="ttdeci">bool valid() const</div><div class="ttdoc">Checks that the class is well-formed, constructed and activated. CanHaveTables needs post-constructor...</div><div class="ttdef"><b>Definition:</b> <a href="Tables_8cpp_source.html#l00247">Tables.cpp:247</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classicedb_1_1Tables_1_1CanHaveTables_ae5b93977857bea7b20303637a31f3f06_cgraph.png" border="0" usemap="#classicedb_1_1Tables_1_1CanHaveTables_ae5b93977857bea7b20303637a31f3f06_cgraph" alt=""/></div>
<map name="classicedb_1_1Tables_1_1CanHaveTables_ae5b93977857bea7b20303637a31f3f06_cgraph" id="classicedb_1_1Tables_1_1CanHaveTables_ae5b93977857bea7b20303637a31f3f06_cgraph">
<area shape="rect" id="node2" href="classicedb_1_1Tables_1_1Table.html#a87e0e23502ba591a6951ec1defaebdb1" title="Checks that Table is well&#45;formed during runtime. Only used internally. " alt="" coords="256,5,396,47"/>
<area shape="rect" id="node3" href="classicedb_1_1Tables_1_1Table.html#a9f9417a43751a0e5c7639ebfae870009" title="Gets the fundamental HDF5 DataSet associated with the table. Only used internally. " alt="" coords="444,5,584,47"/>
</map>
</div>

</div>
</div>
<a id="ade0b5a88f5f8baf5e3dfe10d6a621178"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade0b5a88f5f8baf5e3dfe10d6a621178">&#9670;&nbsp;</a></span>unlinkTable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void icedb::Tables::CanHaveTables::unlinkTable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tableName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlink a table. In HDF5, this is not the same as erasing a table, which never actually happens. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">if</td><td>a table with name tableName does not exist. </td></tr>
    <tr><td class="paramname">if</td><td>the open file is read only </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Tables_8cpp_source.html#l00315">315</a> of file <a class="el" href="Tables_8cpp_source.html">Tables.cpp</a>.</p>

<p class="reference">References <a class="el" href="Tables_8cpp_source.html#l00013">icedb::Tables::Table::valid()</a>.</p>
<div class="fragment"><div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;                                                                  {</div><div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;            Expects(<a class="code" href="classicedb_1_1Tables_1_1CanHaveTables.html#a9b13c766d128573254037748ae3d734d">valid</a>());</div><div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;            <span class="keyword">auto</span> base = <a class="code" href="classicedb_1_1Tables_1_1CanHaveTables.html#a172ec1290f9cbe7a00a78b4498a4c6af">_getTablesParent</a>();</div><div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;            base-&gt;unlink(tableName.c_str());</div><div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;        }</div><div class="ttc" id="classicedb_1_1Tables_1_1CanHaveTables_html_a172ec1290f9cbe7a00a78b4498a4c6af"><div class="ttname"><a href="classicedb_1_1Tables_1_1CanHaveTables.html#a172ec1290f9cbe7a00a78b4498a4c6af">icedb::Tables::CanHaveTables::_getTablesParent</a></div><div class="ttdeci">virtual std::shared_ptr&lt; H5::Group &gt; _getTablesParent() const =0</div><div class="ttdoc">Gets the base HDF5 object that is manipulated. </div></div>
<div class="ttc" id="classicedb_1_1Tables_1_1CanHaveTables_html_a9b13c766d128573254037748ae3d734d"><div class="ttname"><a href="classicedb_1_1Tables_1_1CanHaveTables.html#a9b13c766d128573254037748ae3d734d">icedb::Tables::CanHaveTables::valid</a></div><div class="ttdeci">bool valid() const</div><div class="ttdoc">Checks that the class is well-formed, constructed and activated. CanHaveTables needs post-constructor...</div><div class="ttdef"><b>Definition:</b> <a href="Tables_8cpp_source.html#l00247">Tables.cpp:247</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classicedb_1_1Tables_1_1CanHaveTables_ade0b5a88f5f8baf5e3dfe10d6a621178_cgraph.png" border="0" usemap="#classicedb_1_1Tables_1_1CanHaveTables_ade0b5a88f5f8baf5e3dfe10d6a621178_cgraph" alt=""/></div>
<map name="classicedb_1_1Tables_1_1CanHaveTables_ade0b5a88f5f8baf5e3dfe10d6a621178_cgraph" id="classicedb_1_1Tables_1_1CanHaveTables_ade0b5a88f5f8baf5e3dfe10d6a621178_cgraph">
<area shape="rect" id="node2" href="classicedb_1_1Tables_1_1Table.html#a87e0e23502ba591a6951ec1defaebdb1" title="Checks that Table is well&#45;formed during runtime. Only used internally. " alt="" coords="256,5,396,47"/>
<area shape="rect" id="node3" href="classicedb_1_1Tables_1_1Table.html#a9f9417a43751a0e5c7639ebfae870009" title="Gets the fundamental HDF5 DataSet associated with the table. Only used internally. " alt="" coords="444,5,584,47"/>
</map>
</div>

</div>
</div>
<a id="a9b13c766d128573254037748ae3d734d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b13c766d128573254037748ae3d734d">&#9670;&nbsp;</a></span>valid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool icedb::Tables::CanHaveTables::valid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks that the class is well-formed, constructed and activated. <a class="el" href="classicedb_1_1Tables_1_1CanHaveTables.html" title="The virtual base class used in all objects that can contain tables (groups and datasets). ">CanHaveTables</a> <em>needs</em> post-constructor setup. </p>

<p class="definition">Definition at line <a class="el" href="Tables_8cpp_source.html#l00247">247</a> of file <a class="el" href="Tables_8cpp_source.html">Tables.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;{ <span class="keywordflow">if</span> (<a class="code" href="classicedb_1_1Tables_1_1CanHaveTables.html#a172ec1290f9cbe7a00a78b4498a4c6af">_getTablesParent</a>()) <span class="keywordflow">return</span> <span class="keyword">true</span>; <span class="keywordflow">return</span> <span class="keyword">false</span>; }</div><div class="ttc" id="classicedb_1_1Tables_1_1CanHaveTables_html_a172ec1290f9cbe7a00a78b4498a4c6af"><div class="ttname"><a href="classicedb_1_1Tables_1_1CanHaveTables.html#a172ec1290f9cbe7a00a78b4498a4c6af">icedb::Tables::CanHaveTables::_getTablesParent</a></div><div class="ttdeci">virtual std::shared_ptr&lt; H5::Group &gt; _getTablesParent() const =0</div><div class="ttdoc">Gets the base HDF5 object that is manipulated. </div></div>
</div><!-- fragment -->
</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>lib/icedb/<a class="el" href="Table_8hpp_source.html">Table.hpp</a></li>
<li>lib/src/<a class="el" href="Tables_8cpp_source.html">Tables.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
